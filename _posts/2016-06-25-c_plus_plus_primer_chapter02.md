---
layout: post
title: "C++ primer 读书笔记（一）--- 变量和数据类型"
categories: c++
tags: c++
---

* content
{:toc}

###### 变量和基本类型

* 字符型被分成了三种: `char`/`signed char`/`unsigned char`。尽管字符型有三种，但是字符的表现形式确只有两种: 带符号和无符号的。类型`char`具体表现为上述两种形式的哪一个，是由编译器决定的。
  因为类型`char`在一些机器上是有符号的，在另外一些机器上又是无符号的，所以如果使用`char`进行算数运算特别容易出问题，如果需要使用一个不大的整数时，那么明确指定它的类型是`signed char`或`unsigned char`。

* 执行浮点运算时通常使用`double`，这是因为`float`通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度运算还快。

###### 强制类型转换

* 把一个浮点数赋给整数类型时，仅保留浮点数中小数点之前的部分。

* 把一个整数赋给浮点数类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。

* 赋给无符号整数类型一个超出它表示范围的值时，结果时初始值对无符号类型表示数值总数取模后的余数。

* 赋给有符号整数类型一个超出它表示范围的值时，结果时未定义的（undefined）。程序可能继续工作，可能崩溃，也可能生成垃圾数据。

      int i = 3.14;             //i的值为3
      double pi = 3;            //pi的值为3.0
      unsigned char c = -1;     //假设char占8bits，c的值为255
      signed char c2 = 256;     //假设char占8bits, c2的值是未定义的

* 当一个算术表达式中既有无符号数又有带符号数时，带符号数会转换为无符号数，编程时要尽量避免这种情况发生。因为带符号数为负数时，可能会出现不是我们所期望的结果

###### 字面值常量

* 一个形如 `52` 、 `'a'` 、 `"Hello"` 、 `3.14L` 、 `99LL` 、 `u8"hi!"` 的值被称为字面值常量(literal)。每个字面值常量都对应一种数据类型，字面值常量的形式（前缀/后缀）和值大小决定了它的数据类型。

* 字符和字符串字面值

  由单引号括起来的一个字符称为`char`型字面值

  双括号括起来的零个或多个字符则构成字符串字面值

    前缀 | 含义 | 类型
    --- | --- | ---
    u | Unicode 16 字符 | `char16_t`
    U | Unicode 32 字符 | `char32_t`
    L | 宽字符 | `wchar_t`
    u8 | UTF-8(仅用于字符串字面常量) | `char`


* 整型字面值

  默认情况下，十进制不带后缀的整数字面值是带符号数，它的类型是`int`/`long`/`long long`中能容纳它大小的最小的那个。
  八进制和十六进制不带后缀的整数字面值可能是带符号数，也可能是无符号数，它的类型是`int`/`unsigned int`/`long`/`unsigned long`/`long long`/`unsigned long long`中尺寸最小者。
  类型`short`没有对应的字面值。


    后缀 | 最小匹配类型
    --- | ---
    u or U | `unsigned`
    l or L | `long`
    ll or LL | `long long`


* 浮点型字面值

  默认的，浮点型字面值是一个`double`。


    后缀 | 类型
    --- | ---
    f or F | `float`
    l or L | `long double`


* 布尔字面值

  `true` 和 `false` 是布尔类型的字面值

* 指针字面值

  `nullptr`是指针字面值
 

###### 泛化的转义序列

* 形式为`\x`后紧跟1个或多个十六进制数字，或者`\`后紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。

    `\12` (换行符）`\115` (字符M) `\x4d` (字符M)


      std::cout << "Hi, \x4d-O-\155!\n";    //输出: Hi, M-O-M! 然后换行


  如果反斜线 `\` 后面跟着的八进制数超过3个，只有前3个跟 `\` 构成转义序列。
  相反，`\x` 要用到后面跟着的所有数字，例如，`\x1234` 表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定。因为大多数机器的`char`型数据都是占8位，所以上面这个例子可能会报错。一般来说，超过8位的十六进制字符都是与前面的字符与字符串字面值表中的某个前缀作为开头的扩展字符集一起使用的。 



###### 变量初始化

* C++中，初始化和赋值是两个完全不同的操作。初始化的含义时创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

* 列表初始化

  格式如下:

      int units_sold = {0};
      int units_sold{0};

  当用于内置类型的变量时，如果我们用列表初始化且初始值存在丢失信息的风险，则编译器将报错:
 
      long double ld = 3.1415926536;
      int a{ld}, b = {ld};         // 错误，转换未执行，因为存在丢失信息的危险 
      int c(ld), d = ld;           // 正确，转换执行，且确实丢失了部分值

  ![list initialization](/image/list_initialization.png)


* 默认初始化

  定义于函数体之外的内置变量默认初始化为0。

  定义于函数体内部的内置变量如果没有初始化，则其值未定义。

  类对象如果没有显式的初始化，其值由类确定，如果类要求每个对象都显示初始化，则会引发错误。

* 变量标识符

  标识符的长度没有限制，但是对大小写敏感。

  C++为标准库包保留了一些名字。用户自定义的标识符不能连续出现两个下划线，不能以下划线紧连大写字母开头。此外定义在函数体外的标识符不能以下划线开头。(非强制标准，建议)


###### 复合类型

* 引用

  一般在初始化变量时，初始值会被拷贝到新建的对象中。然而在定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一但初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到一个新的对象，因此引用必须初始化。
  
  引用并非对象，它只是为一个已经存在的对象所起的别名。不能定义引用的引用。

      int ival = 1024;
      int &refVal = ival;     // refVal 指向ival (是ival的另一个名字)
      int &refVal2;           // 错误：引用必须初始化
      refVal = 2;             // 把2赋给refVal指向的对象，此处即是赋给了ival
      int li = refVal;        // 与li = ival执行结果一样
      int &refVal3 = refVal;  // 正确：refVal3绑定到了那个refVal绑定的对象上，这里就是绑定到ival上

      int i = 1024, i2 = 2048;    // i 和 i2都是 int
      int &r = i, r2 = i2;        // r是一个引用，与i绑定在一起，r2是int
      int &r3 =i2, &r4 = i;       // r3 和 r4都是引用

      int &refVal4 = 10;          // 错误：引用类型的初始值必须是一个对象
      double dval = 3.14;
      int &refVal5 = dval;        // 错误：此处引用类型的初始值必须时int型对象

      int a = 8, &ra = a;
      double d = 3.14, &rd = d;
      a = rd;                     // a = 3
      rd = ra;                    // d = 3


* 指针

  得到空指针最直接的办法就是用字面值`nullptr`来初始化指针，这时c++11新标准中引入的一种方法。也可以用名为`NULL`的预处理变量给空指针赋值，这个变量在头文件cstdlib中定义。


      int i = 23;
      int *p;
      int *&r = p;    // r是一个对指针p的引用

      r = &i;         // r引用了一个指针，因此给r赋值&i就是令p指向i
      *r = 0;         // 解引用r得到i，也就是p指向的对象，将i的值改为0


  面对一条比较复杂的指针或引用的声明语句时，从右到左阅读有利于弄清楚它的真实含义。

  指针与引用的区别：

    - 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向不同的对象
    - 指针无须在定义时赋初值。和其他内置类型一样，如果没有初始化，也将拥有一个不确定的值 



###### const限定符

* 因为`const`对象一旦创建后其值就不能再改变，所以`const`对象必须初始化。

* 默认情况下，`const`对象仅在文件内有效，当编译时初始化的方式定义一个`const`对象时，如

      const int bufSize = 512;

  编译器将在编译过程中把用到该变量的地方都替换成对应的值。

  > 如果想在多个文件之间共享`const`对象，必须在变量的定义之前添加`extern`关键字

* 对常量的引用
  
  可以把引用绑定到`const`对象上，就像绑定到其他对象上一样，我们称之为对常量的引用（reference to const）。与普通引用不同的时，对常量的引用不能被用作修改它所绑定的对象。

      const int ci = 1024;
      const int &r1 = ci;        // 正确：引用机器对应的对象都是常量
      r1 = 42;                   // 错误：r1是对常量的引用
      int &r2 = ci;              // 错误：试图让一个非常量引用指向一个常量对象

  前面提到过，引用的类型必须与其所引用的对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式：

      int i = 15;
      const int &r1 = i;         // 允许const int &绑定到一个普通int对象上 r1 = 15
      const int &r2 = 23;        // 正确：r2是一个常量引用 r2 = 23
      const int &r3 = r1 * 2;    // 正确：r3是一个常量引用 r3 = 30
      int &r4 = r1 * 2;          // 错误：r4是一个普通的非常量引用

      r1 = 23;                   // 错误
      i = 33;                    // 正确： r1 = 33, r3 = 30

      double dval = 3.14;
      const int &r5 = dval;      // 正确 r5 = 3

      dval = 23.99;              // 正确 r5 = 3


  必须认识到，常量引用仅对引用可参与的操作做了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径修改它的值。

* 指向常量的指针(pointer to const)

  指向常量的指针和对常量的引用类似。

      const double pi = 3.14;        // pi是个常量，它的值不能改变
      double *ptr = &pi;             // 错误：ptr是一个不同指针
      const double *cptr = &pi;      // 正确：cptr可以指向一个双精度常量
      *cptr = 23;                    // 错误：不能给*cptr赋值

      double dval = 3.14;            // dval是一个双精度浮点数，它的值可以改变
      cptr = &dval;                  // 正确：但是不能通过cptr改变dval的值


* 常量指针（const pointer）

  可以把指针本身定义为常量，常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。

      int errNumb = 0;
      int * const curErr = &errNumb;        // curErr将一直指向errNumb
      *curErr = 10;                         // 正确：errNumb = 10

      const double pi = 3.14159;
      const double * const pip = &pi;       // pip是一个指向常量对象的常量指针
      *pip = 2.72;                          // pip是一个指向常量的指针，常量的值不允许改变


  弄清楚这些声明和定义最行之有效的方法是从右向左阅读。


* 常量表达式（const expression）

  常量表达式是指不会改变并且在编译过程就能得到计算结果的表达式。

  一个对象或表达式是不是常量表达式由它的数据类型和初始值共同决定。

  c++11标准规定，允许就爱那个变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化。




###### 类型别名

* 传统的方式是使用`typedef`关键字

      typedef double wages;        // wages 是double的别名
      typedef wages base, *p;      // base 是double的别名，p是double*的别名

      typedef char *pstring;
      const pstring cstr = 0;      // cstr 是指向char的常量指针
      const pstring *ps;           // ps是一个指针，它的对象是指向char的常量指针


  遇到一条使用了类型别名的声明语句是，往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义：

      const char *cstr = 0;       // 是对const pstring cstr的错误理解

  声明语句中用到pstring时，其基本数据类型是指针。可是使用`char*`重写了声明语句后，数据类型就变成了`char`。前者声明了一个指向`char`的常量指针，改写后的形式则声明了一个指向`const char`的指针。

* c++11新标准方式

      using SI = Sales_item;      // SI是Sales_item的别名

###### 新标准中引入的`auto`类型说明符和`decltype`类型指示符

 
