---
layout: post
title: "C++ primer读书笔记（八）--- Containers "
categories: c++
tags: c++
---

* content
{:toc}

> 顺序容器(sequential container)为程序员提供了控制元素存储和访问顺序的能力。元素在顺序容器中的顺序与其加入容器时的位置相对应。

> 关联容器中元素的位置由元素相关联的关键字值决定。

> 所有容器类都共享公共的接口，不同容器按不同方式对其扩展。这个公共接口使容器的学习更加容易---基于某种容器所学习的内容也都适用于其他容器。每种容器都提供了不同的性能和功能的权衡。

##### 容器公共特性

###### 容器库概述

* 一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。即，deque定义在头文件deque中，list定义在头文件list中，以此类推。

* 容器均定义为模板类。对大多数，但不是所有容器，还需要额外提供元素类型信息，如对于vector，必须提供额外信息来生成特定的容器类型:

      list<Sales_data>      // 保存Sales_data对象的list
      deque<double>         // 保存double的deque

* 可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求，这时，定义的容器就无法执行这些容器操作。
  例如，顺序容器构造函数的一个版本接收容器大小参数，它使用了容器元素类型的默认构造函数。但某些类没有默认构造函数时，我们在构造这种元素类型的容器时，就不能使用该构造函数。

      // 假定 noDefault 是一个没有默认构造函数的类型
      vector<noDefault> v1(10, init);       // 正确:提供了元素初始化器
      vector<noDefault> v2(10);             // 错误:必须提供一个元素初始化器

###### 迭代器

* 与容器一样，迭代器有着公共的接口:
  如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。例如，标准容器类型上的所有迭代器都允许我们访问容器中的元素，而所有迭代器都是通过解引用运算符来实现这个操作的。类似的，标准容器的所有迭代器都提供了递增运算符，从当前元素移动到下一元素。

* 标准容器迭代器的运算符

  *iter| 返回迭代器iter所指向元素的引用
  iter->mem | 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem
  ++iter | 令iter指向容器的下一个元素
  - -iter | 令iter指向容器的上一个元素
  iter1 == iter2 | 判断两个容器是否相等
  iter1 != iter2 | 判断两个容器是否不相等

  > 如果两个迭代器指示的是同一个元素或者是同一个容器的尾后迭代器，则相等；反之，不相等

  > **forward_list的迭代器不支持递减运算符(- -)**

  > 执行解引用的迭代器必须合法并确实指示着某个元素。试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。

* 迭代器支持的算术运算

  |iter + n | 结果仍是一个迭代器，结果迭代器指示的位置与iter相比**向前移动**了n个元素。结果迭代器或者指示容器内的第一个元素，或者指示容器尾元素的下一位置|
  |iter - n | 结果仍是一个迭代器，结果迭代器指示的位置与iter相比**向后移动**了n个元素。结果迭代器或者指示容器内的第一个元素，或者指示容器尾元素的下一位置|
  |iter1 += n | 迭代器加法的复合赋值语句，将iter1加n的结果赋给iter1|
  |iter1 -= n | 迭代器减法的复合赋值语句，将iter1减n的结果赋给iter1|
  |iter1 - iter2 | 两个迭代器相减的结果是它们之间的距离。参与运算的两个迭代器必须指向的是同一个容器|
  |> >= < <= | 如果某个迭代器指向的容器位置在另一个迭代器所指向位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同一个容器|

  > **上述的运算只能用于string、vector、deque和array的迭代器**。不能将它们用于其他任何容器类型的迭代器。

* 获取迭代器

  c.begin() | c.end() | 返回指向容器c的首元素和尾元素之后位置的迭代器
  c.cbegin() | c.cend() | 返回const_iterator
  c.rbegin() | c.rend() | 返回指向容器c的尾元素和首元素之前位置的迭代器
  c.crbegin() | c.crend() | 返回const_reverse_iterator

  > 反向迭代器不支持forward_list

  > 一个迭代器范围（iterator range）由一对迭代器表示，它是一个左闭合区间 [begin, end)，表示范围自begin开始，于end之前（不包括end）结束。
    其中begin和end必须满足下面两个条件:
    1)它们指向同一个容器中的元素，或者是容器最后一个元素之后的位置。
    2)end可以与begin指向相同的位置，但不能指向begin之前的位置，即可以通过反复递增begin来到达end

  > 因为end()操作返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。

  不以c开头的函数都是被重载过的。也就是说，实际上有两个名为begin/rbegin的成员。以c开头的版本是C++11新标准引入的，用于支持auto与begin和end函数的结合使用。

      // 显示指定类型
      list<string>::iterator it5 = a.begin();
      list<string>::const_iterator it6 = a.begin();

      // 是iterator还是const_iterator依赖与a的类型
      auto it7 = a.begin();   // 仅当a是const时，it7是const_iterator
      auto it8 = a.cbegin();  // it8是const_iterator

  当auto与begin或end结合使用时，获得的迭代器类型依赖于容器类型。但以c开头的版本还是可以获得const_iterator的，而不管容器的类型是什么。


###### 容器类型成员

* 类型成员信息见下表

    iterator | 此容器类型的迭代器类型 
    const_iterator | 可以读取元素，但不能修改元素的迭代器类型 
    size_type | 无符号整数类型，足够保存此种容器类型最大可能容器的大小
    difference_type | 带符号整数类型，足够保存两个迭代器之间的距离
    value_type | 元素类型
    reference | 元素的左值类型: 与value_type&含义相同
    const_reference | 元素的const左值类型（即 const value_type& )
    reverse_iterator | 按逆序寻址元素的迭代器
    const_reverse_iterator | 不能修改元素的逆序迭代器

    > 反向迭代器 **reverse_iterator 和 const_reverse_iterator 不支持forward_list**容器。它是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义都发生了颠倒。例如，对一个反向迭代器执行++操作，会得到上一个元素。

    > 通过value_type、reference和const_reference，可以在不了解容器中元素类型的情况下使用它。如果需要元素类型，可以使用容器的value_type。如果需要元素的一个引用，可以使用reference或const_reference。这些元素相关的类型别名在泛型编程中非常有用。

* 容器类型成员使用举例:

      list<string>::iterator iter;
      vector<int>::difference_type count;

###### 容器定义和初始化

* 容器定义和初始化操作
  
  操作 | 描述 | array容器附加要求
  C c; | 默认构造函数。| c中元素按默认方式初始化。
  C c1(c2) | c1初始化为c2的拷贝。c1和c2必须是相同类型 | 两个相同类型且相同大小 
  C c1 = c2 | 同上 | 同上
  C c{a,b,c...} | c初始化为初始化列表中的元素的拷贝。列表中元素类型必须与c的元素类型相容 | 列表中元素数目必须等于或小于array的大小，任何遗漏的元素都进行值初始化
  C c={a,b,c...} | 同上 | 同上
  C c(b,e) | c初始化为迭代器b和e指定范围中的元素拷贝。范围中元素的类型必须与C的元素类型相容 | array不支持 


   > 每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器。
  
   > 对于除array之外的容器，使用列表初始化方式进行初始化时，隐含的指定了容器的大小: 容器将包含与初始值一样多的元素。

   > c1 和 c2 必须是**相同类型容器**要求: 它们必须是相同的容器类型 且 保存的是相同的元素类型。

   > **元素类型相容**指，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。 


* 代码举例:

      // 每个容器有三个元素，用给定的初始化器进行初始化
      list<string> authors = {"Milton", "Shakespeare", "Austen"};
      vector<const char*> articles = {"a", "an", "the"};

      list<string> list2(authors);  // 正确: 类型匹配
      deque<string> deque1(authors); // 错误: 容器类型不匹配
      vector<string> vector1(articles); // 错误: 容器元素类型不匹配

      // 正确: 可以将const char* 转换为string
      forward_list<string> words(articles.begin(), articles.end());
      // 正确: 拷贝元素，直到(但不包括)it指向的元素 (假设it表示authors中的一个元素)
      deque<string> authList(authors.begin(), it);

      array<int, 32> a1;  // 类型为 保存32个int的数组
      array<string, 10> a2; // 类型为 保存10个string的数组
      array<int, 10>::size_type i; // 正确
      array<int>::size_type j; // 错误: array<int> 不是一个类型


###### 容器赋值和swap



###### 容器关系运算


###### 容器大小


###### 容器添加/删除元素



##### 顺序容器

###### 顺序容器类型

* 下表列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。但是这些容器在以下方面都有不同的性能折中。
  + 向容器中添加或从容器中删除元素的代价
  + 非顺序访问容器中元素的代价

  类型|描述|添加删除元素操作|元素访问方式|尾部插入删除元素|头部插入删除元素|其他位置插入删除元素
  array| 固定大小数组 | X | 快速随机访问| X | X | X
  vector| 可变大小数组 | 支持 | 快速随机访问 | 快速 | 可能很慢 | 可能很慢 
  string| 与vector类似的容器，专门用于保存字符 | 支持 | 快速随机访问 | 快速 | 可能很慢 | 可能很慢
  list| 双向链表 | 支持 | 双向顺序访问 | 快速 | 快速 | 快速
  forward_list| 单向链表 | 支持 | 单向顺序访问 | 快速 | 快速 | 快速
  deque| 双端队列 | 支持 | 快速随机访问 | 快速 | 快速 | 可能很慢

  > 现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。

* 顺序容器选择原则
  + 除非你有很好的理由选择其他容器，否则应使用vector。
  + 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list。
  + 如果程序要求随机访问元素，应使用vector或deque。
  + 如果程序要求在容器的中间位置插入或删除元素，应使用list或forward_list。
  + 如果程序要求在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。
  + 如果程序只有在读取输入时才需要在容器的中间位置插入元素，随后需要随机访问元素
    - 首先，确认是否真的需要在容器中间插入元素。当处理输入数据时，通常可以很容易的向vector追加数据，然后调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素。
    - 如果必须在中间位置插入元素，考虑在输入时使用list，一旦输入完成，将list中的内容拷贝到一个vector中。

  > 如果程序中既需要随机访问元素，又要在容器中间位置插入元素，容器选择取决于 在list或forward_list中访问元素与vector或deque中插入/删除元素的相对性能。一般来说，应用中占主导地位的操作决定了容器类型的选择。在此情况下，对两种容器分别测试应用性能可能就是必须的了。

  > 如果不确定使用哪种容器，可以在程序中只使用vector和list公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用vector或list都很方便。


###### 公共容器操作

* 与顺序容器大小相关的构造函数

  除了与关联容器相同的构造函数外，顺序容器(array除外)还提供另一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。

  C seq(n) | seq 包含n个元素，这些元素进行了值初始化；此构造函数是explicit的。 | array不支持
  C seq(n, t) | seq 包含n个初始化为值t的元素 | array部支持

      vector<int> ivec(10, -1);       // 10个int元素，每个都初始化为-1
      list<string> svec( 10, "hi");   // 10个string元素，每个都初始化为"hi"
      forward_list<int> ivec(10);     // 10个int元素，每个都初始化为0
      deque<string> svec(10);         // 10个元素，每个都是空string

  > 如果容器中的元素是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数；如果元素是没有默认构造函数的类类型，除了大小参数外，还必须指定一个显示的元素初始值。

  > 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。

* array容器说明

  > 与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，必须同时指定元素类型和容器大小。

  > 默认构造的array是非空的: 它包含了与其大小一样多的元素。 这些元素都被默认初始化。

  > 对array进行列表初始化时，初始值的数目必须小于等于array容器的大小。如果初始值数目小于array的大小，则后面剩余的元素都会进行默认初始化。

  > 不能对内置数组类型进行拷贝或对象赋值操作，但是可以对array进行，要求两者必须容器类型、元素类型和容器大小都一致。

      array<int, 10> ia1;            // 10个默认初始化的int
      array<int, 10> ia2 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // 列表初始化
      array<int, 10> ia3 = {3};      // ia3[0]为3，剩余元素为0

      int digs[3] = {0, 1, 2};
      int cpy[3] = digs;           // 错误: 内置数组不支持拷贝或赋值
      array<int, 3> digits = {0, 1 2};
      array<int, 3> copy = digits;  // 正确: 只要数组类型和大小匹配就合法


 
