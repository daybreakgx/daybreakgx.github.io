---
layout: post
title: "C++ primer读书笔记（八）--- Containers "
categories: c++
tags: c++
---

* content
{:toc}

> 顺序容器(sequential container)为程序员提供了控制元素存储和访问顺序的能力。元素在顺序容器中的顺序与其加入容器时的位置相对应。

> 关联容器中元素的位置由元素相关联的关键字值决定。

> 所有容器类都共享公共的接口，不同容器按不同方式对其扩展。这个公共接口使容器的学习更加容易---基于某种容器所学习的内容也都适用于其他容器。每种容器都提供了不同的性能和功能的权衡。

##### 容器公共特性

###### 容器库概述

* 一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。即，deque定义在头文件deque中，list定义在头文件list中，以此类推。

* 容器均定义为模板类。对大多数，但不是所有容器，还需要额外提供元素类型信息，如对与vector，必须提供额外信息来生成特定的容器类型:

      list<Sales_data>      // 保存Sales_data对象的list
      deque<double>         // 保存double的deque

* 可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求，这时，定义的容器就无法执行这些容器操作。
  例如，顺序容器构造函数的一个版本接收容器大小参数，它使用了容器元素类型的默认构造函数。但某些类没有默认构造函数时，我们在构造这种元素类型的容器时，就不能使用该构造函数。

      // 假定 noDefault 是一个没有默认构造函数的类型
      vector<noDefault> v1(10, init);       // 正确:提供了元素初始化器
      vector<noDefault> v2(10);             // 错误:必须提供一个元素初始化器

###### 迭代器

* 与容器一样，迭代器有者公共的接口:如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。例如，标准容器类型上的所有迭代器都允许我们访问容器中的元素，而所有迭代器都是通过解引用运算符来实现这个操作的。类似的，标准容器的所有迭代器都提供了递增运算符，从当前元素移动到下一元素。

* 标准容器迭代器的运算符

  *iter| 返回迭代器iter所指向元素的引用
  iter->mem | 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem
  ++iter | 令iter指向容器的下一个元素
  - -iter | 令iter指向容器的上一个元素
  iter1 == iter2 | 判断两个容器是否相等
  iter1 != iter2 | 判断两个容器是否不相等

  > 如果两个迭代器指示的是同一个元素或者是同一个容器的尾后迭代器，则相等；反之，不相等

  > **forward_list的迭代器不支持递减运算符(- -)**

  > 执行解引用的迭代器必须合法并确实指示着某个元素。试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。


###### 容器类型成员

* 类型成员信息见下表

    iterator | 此容器类型的迭代器类型 
    const_iterator | 可以读取元素，但不能修改元素的迭代器类型 
    size_type | 无符号整数类型，足够保存此种容器类型最大可能容器的大小
    difference_type | 带符号整数类型，足够保存两个迭代器之间的距离
    value_type | 元素类型
    reference | 元素的左值类型: 与value_type&含义相同
    const_reference | 元素的const左值类型（即 const value_type& )
    reverse_iterator | 按逆序寻址元素的迭代器
    const_reverse_iterator | 不能修改元素的逆序迭代器

* 反向迭代器 **reverse_iterator 和 const_reverse_iterator 不支持forward_list**容器。它是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义都发生了颠倒。例如，对一个反向迭代器执行++操作，会得到上一个元素。

* 通过value_type、reference和const_reference，可以在不了解容器中元素类型的情况下使用它。如果需要元素类型，可以使用容器的value_type。如果需要元素的一个引用，可以使用reference或const_reference。这些元素相关的类型别名在泛型编程中非常有用。

* 容器类型成员使用举例:

      list<string>::iterator iter;
      vector<int>::difference_type count;



##### 顺序容器

###### 顺序容器类型

* 下表列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。但是这些容器在以下方面都有不同的性能折中。
  + 向容器中添加或从容器中删除元素的代价
  + 非顺序访问容器中元素的代价

  类型|描述|添加删除元素操作|元素访问方式|尾部插入删除元素|头部插入删除元素|其他位置插入删除元素
  array| 固定大小数组 | X | 快速随机访问| X | X | X
  vector| 可变大小数组 | 支持 | 快速随机访问 | 快速 | 可能很慢 | 可能很慢 
  string| 与vector类似的容器，专门用于保存字符 | 支持 | 快速随机访问 | 快速 | 可能很慢 | 可能很慢
  list| 双向链表 | 支持 | 双向顺序访问 | 快速 | 快速 | 快速
  forward_list| 单向链表 | 支持 | 单向顺序访问 | 快速 | 快速 | 快速
  deque| 双端队列 | 支持 | 快速随机访问 | 快速 | 快速 | 可能很慢

  > 现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。

* 顺序容器选择原则
  + 除非你有很好的理由选择其他容器，否则应使用vector。
  + 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list。
  + 如果程序要求随机访问元素，应使用vector或deque。
  + 如果程序要求在容器的中间位置插入或删除元素，应使用list或forward_list。
  + 如果程序要求在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。
  + 如果程序只有在读取输入时才需要在容器的中间位置插入元素，随后需要随机访问元素
    - 首先，确认是否真的需要在容器中间插入元素。当处理输入数据时，通常可以很容易的向vector追加数据，然后调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素。
    - 如果必须在中间位置插入元素，考虑在输入时使用list，一旦输入完成，将list中的内容拷贝到一个vector中。

  > 如果程序中既需要随机访问元素，又要在容器中间位置插入元素，容器选择取决于 在list或forward_list中访问元素与vector或deque中插入/删除元素的相对性能。一般来说，应用中占主导地位的操作决定了容器类型的选择。在此情况下，对两种容器分别测试应用性能可能就是必须的了。

  > 如果不确定使用哪种容器，可以在程序中只使用vector和list公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用vector或list都很方便。


###### 公共容器操作


