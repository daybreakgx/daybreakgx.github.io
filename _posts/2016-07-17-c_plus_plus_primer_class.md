---
layout: post
title: "C++ primer读书笔记（六）--- 类"
categories: c++
tags: c++
---

* content
{:toc}


> 类的基本思想是**数据抽象(data abstraction)**和**封装(encapsulation)**。

>  数据抽象是一种依赖于**接口(interface)**和**实现(implementation)**分离的编程（以及设计）技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数以及定义类所需的各种私有函数。
  封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

>  类要想实现数据抽象和封装，需要首先定义一个**抽象数据类型(abstract data type)**。在抽象数据类型中，由类的设计者负责考虑类的实现过程；使用该类的程序员则只需要抽象地思考类做了什么，而无须了解类的工作细节。

##### 定义抽象数据类型

###### 定义成员函数

* 定义和声明成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义既可以在类内部也可以在类的外部。作为接口组成部分的非成员函数，他们的定义和声明都在类的外部。

  > 定义在类内部的函数是隐式的inline函数。


      struct Sales_data {
          std::string bookNo;
          unsigned units_sold = 0;
          double revenue = 0.0;

          std::string isbn() const { return bookNo; }
          Sales_data& combine(const Sales_data&);
          double avg_price() const;
      }

      //Sales_data的非成员接口函数
      Sales_data add(const Sales_data&, const Sales_data&);
      std::ostream &print(std::ostream&, const Sales_data&);
      std::instream &read(std::instream&, Sales_data&);
     

  上面的例子中成员函数isbn定义在了类内，而成员函数combine和avg_price函数定义在类外。 

* 在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。也就是说，返回类型、参数列表和函数名都得与类内部的声明保持一致。如果成员函数被声明为常量成员函数，那么它的定义也必须在参数列表后面明确指定const属性。同时，类外部定义的成员的名字必须包含它所属的类名。

      double Sales_data::avg_price() const {
          if(units_sold)
              return revenue/units_sold;
          else
              return 0;
      }

  当avg_price使用revenue和units_sold时，实际上它隐式的使用了Sales_data的成员。


###### 调用成员函数

    Sales_data total;
    total.isbn();

* 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，会用请求该函数的对象地址初始化this。例如上面代码中的total.isbn()，编译器负责把total的地址传递给isbn的隐式形参this，可以等价的认为编译器将该调用重写成了如下的形式：

      //伪代码，用于说明调用成员函数的实际执行过程
      Sales_data::isbn(&total)

* 在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符来做到这一点，因为this所指的就是这个对象。任何对类成员的直接访问都被看作this的隐式引用，也就是说，当isbn函数中使用bookNo时，它隐式的使用this指向的成员，就像我们书写了this->bookNo一样。

* 对我们来说，this形参是隐式定义的。实际上，任何自定义名为this的参数或者变量的行为都是非法的。我们可以在成员函数体内部使用this。因为尽管没有必要，但是我们还是能把isbn函数定义为如下形式：

      std::string isbn() const { return this->bookNo; }

* 因为this的目的总是指向“这个”对象，所以this是一个常量指针，不允许改变this中保存的地址。

* 编译器首先编译成员的声明，然后才轮到成员函数体（如果右的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。


###### const成员函数

* isbn函数中紧随参数列表之后的const关键字的作用是修改隐式this指针的类型。

* 默认情况下，this的类型是指向类类型非常量对象的常量指针，即 class_type* const this。这就意味着（在默认情况下）我们不能把this绑定到一个常量对象上，也就表示不能在常量对象上调用普通的成员函数。

* 如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明成const class_type* const this。毕竟，在isbn的函数体内不会改变this所指的对象，所以把this设置成指向常量的指针有助于提高函数的灵活性。

* 然而，this是隐式的并且不会出现在参数列表中，所以在哪儿将this声明成指向常量的指针就称为一个问题。C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称为**常量成员函数(const member function)**。

      //伪代码，说明隐式this指针是如何使用的
      //下面的代码是非法的：因为我们不能显示地定义自己的this指针
      //谨记此处的this是一个指向常量的指针，isbn是一个常量成员
      std::string Sales_data::isbn(const Sales_data *const this)
      { return this->isbn; }

* 因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。在上例中，isbn可以读取调用它的对象的数据成员，但是不能写入新值。

  > 常量对象，以及常量对象的引用或指针都只能调用常量成员函数。


###### 定义返回this对象的成员函数

* 函数combine的设计初衷类似于复合赋值运算符+=，调用该函数的对象代表的是赋值运算符左侧的运算对象，右侧运算符则通过显示的实参被传入函数。

      Sales_data& Sales_data::combine(const Sales_data& rhs)
      {
          units_sold += rhs.units_sold;
          revenue += rhs.revenue;
          return *this;
      } 

  该函数一个值得关注的部分是它的返回类型和返回语句。一般来说，当我们定义的函数类似与某个内置运算符是，应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左侧运算对象当成左值返回，因此为了与它报纸一致，combine函数必须返回引用类型。

      total.combine(trans);

  return 语句解引用this指针以获得执行该函数的对象，换句话说，上面的这个调用返回total的引用。  


###### 构造函数

* 构造函数的名字和类名相同。和其他函数不同的是，构造函数没有返回类型。类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。

* 不同于其他成员函数，构造函数不能被声明成const的。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。

* 当类没有显示的定义构造函数时，编译器会隐式的定义一个默认构造函数，它又被称为**合成的默认构造函数(synthesized default constructor)**。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：
  
  + 如果存在类内初始值，用它来初始化成员。
  + 否则，默认初始化该成员。

  合成的默认构造函数只适合非常简单的类，对于一个普通的类来说，必须定义它自己的默认构造函数，原因主要包括：
  
  + 编译器只有在发现类不含任何构造函数时，才会生成一个默认的构造函数。一旦我们定义了一些其他构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。
  + 对于某些类来说，合成的默认构造函数可能执行错误的操作。内置类型或复合类型对象在默认初始化时，它们的值是未定义的。
  + 有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。

* 常见构造函数举例

      struct Sales_data {
          // C++11新标准，如果我们需要默认的行为，可以在参数列表后面加上=default来要求编译器生成构造函数 
          Sales_data() = default; 

          // 冒号与大括号之间的部分称为构造函数初始值列表
          Sales_data(const std::string& s): bookNo(s) { }
          Sales_data(const std::string& s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { }
          Sales_data(std::istream&);

          // 默认初始化为空串
          std::string bookNo;
          // 类内初始化
          unsigned units_sold = 0;
          double revenue = 0.0;
      };

      Sales_data::Sales_data(std::istream& is) {
          read(is, *this);
      }

* 通常情况下，构造函数使用类内初始化不失为一种号的选择，因为只要这样的初始值存在，我们就能确保为成员赋予一个正确的值。不过，如果编译器不支持类内初始值，则所有构造函数都应该显示的初始化每一个内置类型的成员。

  > 构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。


##### 类对象的拷贝、赋值和析构

* 除了定义类的对象如何初始化以外，类还需要控制拷贝、赋值和销毁对象时发生的行为。

  + 对象在几种情况下会被拷贝，如我们初始化变量以及以值的方式传递或返回一个对象等。
  + 当我们使用赋值运算符时会发生对象的赋值操作。
  + 当对象不再存在时执行销毁操作，如一个局部对象会在创建它的块结束时被销毁，当vector（或数组）对象销毁时存储在其中的对象也会被销毁。

* 如果我们不主动定义这些操作，编译器会替我们合成他们。一般来说，编译器生成的版本将会把对象的每个成员执行拷贝、赋值和销毁操作。

* 尽管编译器能替我们合成拷贝、赋值和销毁操作，但是对于某些类来说，合成的版本无法工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。不过值得注意的是，很多需要动态内存的类能（而且应该）使用vector对象或string对象管理必要的存储空间。使用vector或者string的类能避免分配和释放内存带来的复杂性。

  > 如果类包含vector或string对象，则其拷贝、赋值和销毁的合成版本能够正常工作。当我们对含有vector成员的对象执行拷贝或者赋值操作是，vector类会设法拷贝或者赋值成员中的元素。当这样的对象被销毁时，将销毁vector对象，也就是依次销毁vector中的每一个元素。这一点与string是非常类似的。



